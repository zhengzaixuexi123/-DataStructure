package org.example.hash_table;

public class array_hash_map {
    public static void main(String[] args) {
        ArrayHashMap map = new ArrayHashMap();
        map.put(12836, "小王");
        map.put(15937, "小章");
        map.put(16750, "小张");
        map.put(13276, "小帅");
        map.put(10583, "小美");
        /*当加入
         * map.put(20583,"小李")
         * 20583 % 100 ==83
         * 10583 % 100 ==83
         * 出现hash冲突 */

        /*扩容数组会降低哈希冲突的出现，当扩容到300的数组容量时
         * 20583 % 300 == 183
         * 10583 % 300 == 83
         * 哈希冲突得到解决*/

        /*
         * 由于扩容哈希表需要把旧哈希表复制到新哈希表中非常耗时，由于重赋值capacity，会
         * 重新计算哈希值，这进一步增加了扩容过程的计算开销。
         * 、为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。*/

        /*负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，
        用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过
        0.75 时，系统会将哈希表扩容至原先的
        倍。*/
    }
}
